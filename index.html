<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Interactive Street Walkthrough</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #111;
    }
    canvas { 
      display: block; 
    }
    #loading {
      position: fixed;
      top: 0; 
      left: 0;
      width: 100%; 
      height: 100%;
      background: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      z-index: 10;
      transition: opacity 0.5s ease-out;
    }
    .progress-bar {
      width: 300px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      margin-top: 20px;
      overflow: hidden;
    }
    .progress {
      height: 100%;
      background: #4CAF50;
      width: 0%;
      transition: width 0.3s ease;
    }
    #instructions {
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      z-index: 100;
      font-size: 16px;
      transition: opacity 0.5s;
    }
    #error {
      display: none;
      color: #ff5555;
      margin-top: 20px;
      text-align: center;
      max-width: 80%;
    }
    #credits {
      position: fixed;
      top: 20px;
      right: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px 15px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 5;
    }
  </style>
</head>
<body>
<div id="loading">
  <div>Loading street environment...</div>
  <div class="progress-bar">
    <div class="progress" id="progress"></div>
  </div>
  <div id="error"></div>
</div>

<div id="instructions">
  Click to activate controls | W, A, S, D to move | Mouse to look around
</div>

<div id="credits">
  Three.js Street Walkthrough
</div>

<!-- Using ES modules as recommended by Three.js -->
<script type="module">
  // Import Three.js using ES modules
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';
  import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/controls/PointerLockControls.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/loaders/GLTFLoader.js';

  // Main variables
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x88ccff);
  scene.fog = new THREE.Fog(0x88ccff, 10, 50);
  
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.6, 5);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Lighting
  const ambientLight = new THREE.AmbientLight(0x606060);
  scene.add(ambientLight);

  const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
  light.position.set(0, 20, 0);
  scene.add(light);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(10, 20, 10);
  directionalLight.castShadow = true;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 50;
  directionalLight.shadow.camera.left = -20;
  directionalLight.shadow.camera.right = 20;
  directionalLight.shadow.camera.top = 20;
  directionalLight.shadow.camera.bottom = -20;
  scene.add(directionalLight);

  // Create a simple ground plane as fallback
  const groundGeometry = new THREE.PlaneGeometry(100, 100);
  const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228822, roughness: 0.8 });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.1;
  ground.receiveShadow = true;
  scene.add(ground);

  // Create a road
  const roadGeometry = new THREE.PlaneGeometry(10, 100);
  const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI / 2;
  road.position.y = 0.01;
  road.receiveShadow = true;
  scene.add(road);

  // Add road markings
  for (let i = -10; i < 10; i += 2) {
    const markingGeometry = new THREE.PlaneGeometry(0.5, 2);
    const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const marking = new THREE.Mesh(markingGeometry, markingMaterial);
    marking.rotation.x = -Math.PI / 2;
    marking.position.set(0, 0.02, i * 5);
    scene.add(marking);
  }

  // Create some placeholder buildings since the GLB files aren't available
  function createPlaceholderBuildings() {
    const buildingColors = [0xcc5555, 0x55cc55, 0x5555cc, 0xcccc55, 0xcc55cc];
    
    for (let i = -4; i <= 4; i += 2) {
      for (let j = -20; j <= 20; j += 5) {
        if (Math.abs(i) < 2 && Math.abs(j) < 5) continue; // Skip center where player is
        
        const height = 5 + Math.random() * 10;
        const width = 1.5 + Math.random() * 1.5;
        const depth = 1.5 + Math.random() * 1.5;
        
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({ 
          color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
          roughness: 0.8
        });
        
        const building = new THREE.Mesh(geometry, material);
        building.position.set(i * 5, height/2, j);
        building.castShadow = true;
        building.receiveShadow = true;
        scene.add(building);
      }
    }
  }

  // Add some trees
  function createTrees() {
    for (let i = -30; i <= 30; i += 5) {
      if (i === 0) continue;
      
      // Tree trunk
      const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2);
      const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.set(7, 1, i);
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      scene.add(trunk);
      
      // Tree foliage
      const foliageGeometry = new THREE.SphereGeometry(1.5, 8, 8);
      const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228822 });
      const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
      foliage.position.set(7, 2.5, i);
      foliage.castShadow = true;
      foliage.receiveShadow = true;
      scene.add(foliage);
    }
  }

  // Loader setup
  const loader = new GLTFLoader();
  const parts = [
    "street_part1.glb","street_part2.glb","street_part3.glb",
    "street_part4.glb","street_part5.glb","street_part6.glb",
    "street_part7.glb","street_part8.glb","street_part9.glb"
  ];

  let loadedCount = 0;
  const loadingDiv = document.getElementById('loading');
  const progressBar = document.getElementById('progress');
  const errorDiv = document.getElementById('error');

  // Try to load models, but fallback to placeholder if they don't exist
  parts.forEach(file => {
    loader.load(file, 
      function(gltf){
        scene.add(gltf.scene);
        loadedCount++;
        updateProgress();
      }, 
      function(xhr) {
        // Progress updates can be handled here if needed
        const percent = (xhr.loaded / xhr.total) * 100;
        console.log(`${file} ${percent.toFixed(2)}% loaded`);
      },
      function(error){
        console.error("Error loading " + file, error);
        loadedCount++;
        updateProgress();
        
        // Show error message but continue
        errorDiv.style.display = 'block';
        errorDiv.innerHTML = `Could not load ${file}. Using placeholder environment.`;
      }
    );
  });

  function updateProgress() {
    const progress = (loadedCount / parts.length) * 100;
    progressBar.style.width = progress + '%';
    loadingDiv.querySelector('div').textContent = `Loading street... (${loadedCount}/${parts.length})`;
    
    if (loadedCount === parts.length) {
      // If nothing was loaded, create placeholder buildings
      if (scene.children.filter(child => child.type === 'Group').length < 2) {
        createPlaceholderBuildings();
        createTrees();
      }
      
      // Fade out loading screen
      setTimeout(() => {
        loadingDiv.style.opacity = '0';
        setTimeout(() => {
          loadingDiv.style.display = 'none';
        }, 500);
      }, 1000);
    }
  }

  // Controls setup
  const controls = new PointerLockControls(camera, document.body);
  
  // Instructions and click handling
  const instructions = document.getElementById('instructions');
  instructions.style.display = 'block';
  
  document.body.addEventListener('click', () => {
    if (!controls.isLocked) {
      controls.lock();
    }
  });
  
  controls.addEventListener('lock', () => {
    instructions.style.display = 'none';
  });
  
  controls.addEventListener('unlock', () => {
    instructions.style.display = 'block';
  });

  // Movement controls
  const moveSpeed = 0.15;
  const keys = {};
  
  document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
  });
  
  document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
  });

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    
    if (controls.isLocked) {
      // Handle movement
      if (keys['KeyW']) controls.moveForward(moveSpeed);
      if (keys['KeyS']) controls.moveForward(-moveSpeed);
      if (keys['KeyA']) controls.moveRight(-moveSpeed);
      if (keys['KeyD']) controls.moveRight(moveSpeed);
    }
    
    renderer.render(scene, camera);
  }
  
  // Handle window resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Start the animation
  animate();
  createPlaceholderBuildings();
  createTrees();
  updateProgress();
</script>
</body>
</html>
