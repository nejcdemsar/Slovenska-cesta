<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Street Facade Viewer</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #333;
        }
        #container { 
            position: absolute; 
            width: 100%; 
            height: 100%; 
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background: linear-gradient(to right, rgba(0,0,0,0.7), rgba(40,40,40,0.8), rgba(0,0,0,0.7));
            padding: 12px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 100;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 101;
            min-width: 200px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
        }
        #progress-bar {
            width: 100%;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            margin-top: 15px;
            overflow: hidden;
        }
        #progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #4facfe, #00f2fe);
            transition: width 0.3s;
            border-radius: 10px;
        }
        h1 {
            margin: 0;
            font-size: 2.2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 1px;
        }
        h3 {
            margin-top: 0;
            color: #4facfe;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        .key {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            padding: 3px 8px;
            margin: 2px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            font-family: monospace;
        }
        #loading-text {
            margin-top: 10px;
            font-size: 1.1em;
        }
        .credit {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background-color: rgba(0,0,0,0.6);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="info">
        <h1>Historic Street Facade Explorer</h1>
    </div>
    
    <div id="instructions">
        <h3>Controls:</h3>
        <p><span class="key">W</span> / <span class="key">↑</span> : Move forward</p>
        <p><span class="key">S</span> / <span class="key">↓</span> : Move backward</p>
        <p><span class="key">A</span> / <span class="key">←</span> : Move left</p>
        <p><span class="key">D</span> / <span class="key">→</span> : Move right</p>
        <p><span class="key">Space</span> : Move up</p>
        <p><span class="key">Shift</span> : Move down</p>
        <p><span class="key">R</span> : Reset position</p>
        <p>Click to lock controls and explore</p>
    </div>
    
    <div id="loading">
        <h2>Loading Street Model</h2>
        <div id="progress-bar">
            <div id="progress"></div>
        </div>
        <div id="loading-text">Loading part 1 of 9...</div>
    </div>
    
    <div class="credit">Created with Three.js | Faculty Project</div>

    <!-- Load Three.js and necessary addons from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Main script
        let camera, scene, renderer, controls;
        let modelParts = [];
        let loadedParts = 0;
        let totalParts = 9;
        
        // Movement state
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;

        init();
        animate();

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x88ccff);
            scene.fog = new THREE.Fog(0x88ccff, 10, 100);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 5);

            // Create lights
            const ambientLight = new THREE.AmbientLight(0x606060, 1.2);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 0.5).normalize();
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            // Create controls
            controls = new THREE.PointerLockControls(camera, document.body);
            
            const instructionsElement = document.getElementById('instructions');
            
            instructionsElement.addEventListener('click', function () {
                controls.lock();
            });
            
            controls.addEventListener('lock', function () {
                instructionsElement.style.display = 'none';
            });
            
            controls.addEventListener('unlock', function () {
                instructionsElement.style.display = 'block';
            });
            
            scene.add(controls.getObject());

            // Load all parts of your 3D model
            const loader = new THREE.GLTFLoader();
            
            for (let i = 1; i <= totalParts; i++) {
                const partName = `street_part${i}.glb`;
                loader.load(partName, 
                    function (gltf) {
                        loadedParts++;
                        const modelPart = gltf.scene;
                        scene.add(modelPart);
                        modelParts.push(modelPart);
                        
                        // Update progress
                        const progressPercent = (loadedParts / totalParts) * 100;
                        document.getElementById('progress').style.width = `${progressPercent}%`;
                        document.getElementById('loading-text').textContent = `Loading part ${loadedParts} of ${totalParts}...`;
                        
                        // If all parts are loaded, hide loading screen
                        if (loadedParts === totalParts) {
                            setTimeout(() => {
                                document.getElementById('loading').style.display = 'none';
                                document.getElementById('instructions').style.display = 'block';
                            }, 1000);
                        }
                    },
                    function (xhr) {
                        // Progress callback (optional)
                    },
                    function (error) {
                        console.error(`Error loading model part ${i}:`, error);
                        loadedParts++; // Still count as loaded to avoid infinite loading
                    }
                );
            }

            // Create simple ground plane
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 10, 10);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a6b35,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);

            // Add some simple environment elements
            addEnvironment();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Add keyboard controls for movement
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
        }

        function addEnvironment() {
            // Add a skybox
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x88ccff, 
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            // Add some simple trees
            for (let i = 0; i < 20; i++) {
                const tree = createTree();
                tree.position.x = (Math.random() - 0.5) * 100;
                tree.position.z = (Math.random() - 0.5) * 100;
                tree.position.y = -0.5;
                scene.add(tree);
            }
        }
        
        function createTree() {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x6d4c3d });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1;
            trunk.castShadow = true;
            group.add(trunk);
            
            // Foliage
            const foliageGeometry = new THREE.ConeGeometry(1.5, 4, 8);
            const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x3c8d40 });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 3;
            foliage.castShadow = true;
            group.add(foliage);
            
            return group;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    moveUp = true;
                    break;
                case 'ShiftLeft':
                    moveDown = true;
                    break;
                case 'KeyR': // Reset position
                    controls.getObject().position.set(0, 1.6, 5);
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'Space':
                    moveUp = false;
                    break;
                case 'ShiftLeft':
                    moveDown = false;
                    break;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (controls.isLocked === true) {
                const delta = 0.1; // Adjust movement speed here
                
                const velocity = new THREE.Vector3();
                const direction = new THREE.Vector3();

                if (moveForward || moveBackward) velocity.z -= (moveForward ? 1 : -1) * 5.0 * delta;
                if (moveLeft || moveRight) velocity.x -= (moveLeft ? 1 : -1) * 5.0 * delta;
                if (moveUp || moveDown) velocity.y -= (moveUp ? 1 : -1) * 5.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
